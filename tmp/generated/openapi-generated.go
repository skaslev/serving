// +build !ignore_autogenerated

/*
Copyright 2020 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by openapi-gen. DO NOT EDIT.

// This file was autogenerated by openapi-gen. Do not edit it manually!

package generated

import (
	spec "github.com/go-openapi/spec"
	common "k8s.io/kube-openapi/pkg/common"
	apis "knative.dev/pkg/apis"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"knative.dev/pkg/apis.Condition":                                             schema_knativedev_pkg_apis_Condition(ref),
		"knative.dev/pkg/apis.ConditionSet":                                          schema_knativedev_pkg_apis_ConditionSet(ref),
		"knative.dev/pkg/apis.FieldError":                                            schema_knativedev_pkg_apis_FieldError(ref),
		"knative.dev/pkg/apis.URL":                                                   schema_knativedev_pkg_apis_URL(ref),
		"knative.dev/pkg/apis.VolatileTime":                                          schema_knativedev_pkg_apis_VolatileTime(ref),
		"knative.dev/pkg/apis.allowDifferentNamespace":                               schema_knativedev_pkg_apis_allowDifferentNamespace(ref),
		"knative.dev/pkg/apis.conditionsImpl":                                        schema_knativedev_pkg_apis_conditionsImpl(ref),
		"knative.dev/pkg/apis.disallowDeprecated":                                    schema_knativedev_pkg_apis_disallowDeprecated(ref),
		"knative.dev/pkg/apis.inCreateKey":                                           schema_knativedev_pkg_apis_inCreateKey(ref),
		"knative.dev/pkg/apis.inDeleteKey":                                           schema_knativedev_pkg_apis_inDeleteKey(ref),
		"knative.dev/pkg/apis.inSpec":                                                schema_knativedev_pkg_apis_inSpec(ref),
		"knative.dev/pkg/apis.inStatus":                                              schema_knativedev_pkg_apis_inStatus(ref),
		"knative.dev/pkg/apis.inUpdateKey":                                           schema_knativedev_pkg_apis_inUpdateKey(ref),
		"knative.dev/pkg/apis.isDryRun":                                              schema_knativedev_pkg_apis_isDryRun(ref),
		"knative.dev/pkg/apis.parentMetaKey":                                         schema_knativedev_pkg_apis_parentMetaKey(ref),
		"knative.dev/pkg/apis.updatePayload":                                         schema_knativedev_pkg_apis_updatePayload(ref),
		"knative.dev/pkg/apis.userInfoKey":                                           schema_knativedev_pkg_apis_userInfoKey(ref),
		"knative.dev/pkg/apis/duck/v1.AddressStatus":                                 schema_pkg_apis_duck_v1_AddressStatus(ref),
		"knative.dev/pkg/apis/duck/v1.Addressable":                                   schema_pkg_apis_duck_v1_Addressable(ref),
		"knative.dev/pkg/apis/duck/v1.AddressableType":                               schema_pkg_apis_duck_v1_AddressableType(ref),
		"knative.dev/pkg/apis/duck/v1.AddressableTypeList":                           schema_pkg_apis_duck_v1_AddressableTypeList(ref),
		"knative.dev/pkg/apis/duck/v1.CloudEventAttributes":                          schema_pkg_apis_duck_v1_CloudEventAttributes(ref),
		"knative.dev/pkg/apis/duck/v1.CloudEventOverrides":                           schema_pkg_apis_duck_v1_CloudEventOverrides(ref),
		"knative.dev/pkg/apis/duck/v1.Destination":                                   schema_pkg_apis_duck_v1_Destination(ref),
		"knative.dev/pkg/apis/duck/v1.KReference":                                    schema_pkg_apis_duck_v1_KReference(ref),
		"knative.dev/pkg/apis/duck/v1.KResource":                                     schema_pkg_apis_duck_v1_KResource(ref),
		"knative.dev/pkg/apis/duck/v1.KResourceList":                                 schema_pkg_apis_duck_v1_KResourceList(ref),
		"knative.dev/pkg/apis/duck/v1.PodSpecable":                                   schema_pkg_apis_duck_v1_PodSpecable(ref),
		"knative.dev/pkg/apis/duck/v1.Source":                                        schema_pkg_apis_duck_v1_Source(ref),
		"knative.dev/pkg/apis/duck/v1.SourceList":                                    schema_pkg_apis_duck_v1_SourceList(ref),
		"knative.dev/pkg/apis/duck/v1.SourceSpec":                                    schema_pkg_apis_duck_v1_SourceSpec(ref),
		"knative.dev/pkg/apis/duck/v1.SourceStatus":                                  schema_pkg_apis_duck_v1_SourceStatus(ref),
		"knative.dev/pkg/apis/duck/v1.Status":                                        schema_pkg_apis_duck_v1_Status(ref),
		"knative.dev/pkg/apis/duck/v1.WithPod":                                       schema_pkg_apis_duck_v1_WithPod(ref),
		"knative.dev/pkg/apis/duck/v1.WithPodList":                                   schema_pkg_apis_duck_v1_WithPodList(ref),
		"knative.dev/pkg/apis/duck/v1.WithPodSpec":                                   schema_pkg_apis_duck_v1_WithPodSpec(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.AddressStatus":                           schema_pkg_apis_duck_v1alpha1_AddressStatus(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.Addressable":                             schema_pkg_apis_duck_v1alpha1_Addressable(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.AddressableType":                         schema_pkg_apis_duck_v1alpha1_AddressableType(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.AddressableTypeList":                     schema_pkg_apis_duck_v1alpha1_AddressableTypeList(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.Binding":                                 schema_pkg_apis_duck_v1alpha1_Binding(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.BindingList":                             schema_pkg_apis_duck_v1alpha1_BindingList(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.BindingSpec":                             schema_pkg_apis_duck_v1alpha1_BindingSpec(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.LegacyTarget":                            schema_pkg_apis_duck_v1alpha1_LegacyTarget(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.LegacyTargetList":                        schema_pkg_apis_duck_v1alpha1_LegacyTargetList(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.LegacyTargetable":                        schema_pkg_apis_duck_v1alpha1_LegacyTargetable(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.Target":                                  schema_pkg_apis_duck_v1alpha1_Target(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.TargetList":                              schema_pkg_apis_duck_v1alpha1_TargetList(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.TargetStatus":                            schema_pkg_apis_duck_v1alpha1_TargetStatus(ref),
		"knative.dev/pkg/apis/duck/v1alpha1.Targetable":                              schema_pkg_apis_duck_v1alpha1_Targetable(ref),
		"knative.dev/pkg/apis/duck/v1beta1.AddressStatus":                            schema_pkg_apis_duck_v1beta1_AddressStatus(ref),
		"knative.dev/pkg/apis/duck/v1beta1.Addressable":                              schema_pkg_apis_duck_v1beta1_Addressable(ref),
		"knative.dev/pkg/apis/duck/v1beta1.AddressableType":                          schema_pkg_apis_duck_v1beta1_AddressableType(ref),
		"knative.dev/pkg/apis/duck/v1beta1.AddressableTypeList":                      schema_pkg_apis_duck_v1beta1_AddressableTypeList(ref),
		"knative.dev/pkg/apis/duck/v1beta1.CloudEventOverrides":                      schema_pkg_apis_duck_v1beta1_CloudEventOverrides(ref),
		"knative.dev/pkg/apis/duck/v1beta1.Destination":                              schema_pkg_apis_duck_v1beta1_Destination(ref),
		"knative.dev/pkg/apis/duck/v1beta1.KResource":                                schema_pkg_apis_duck_v1beta1_KResource(ref),
		"knative.dev/pkg/apis/duck/v1beta1.KResourceList":                            schema_pkg_apis_duck_v1beta1_KResourceList(ref),
		"knative.dev/pkg/apis/duck/v1beta1.Source":                                   schema_pkg_apis_duck_v1beta1_Source(ref),
		"knative.dev/pkg/apis/duck/v1beta1.SourceList":                               schema_pkg_apis_duck_v1beta1_SourceList(ref),
		"knative.dev/pkg/apis/duck/v1beta1.SourceSpec":                               schema_pkg_apis_duck_v1beta1_SourceSpec(ref),
		"knative.dev/pkg/apis/duck/v1beta1.SourceStatus":                             schema_pkg_apis_duck_v1beta1_SourceStatus(ref),
		"knative.dev/pkg/apis/duck/v1beta1.Status":                                   schema_pkg_apis_duck_v1beta1_Status(ref),
		"knative.dev/serving/pkg/apis/autoscaling/v1alpha1.Metric":                   schema_pkg_apis_autoscaling_v1alpha1_Metric(ref),
		"knative.dev/serving/pkg/apis/autoscaling/v1alpha1.MetricList":               schema_pkg_apis_autoscaling_v1alpha1_MetricList(ref),
		"knative.dev/serving/pkg/apis/autoscaling/v1alpha1.MetricSpec":               schema_pkg_apis_autoscaling_v1alpha1_MetricSpec(ref),
		"knative.dev/serving/pkg/apis/autoscaling/v1alpha1.MetricStatus":             schema_pkg_apis_autoscaling_v1alpha1_MetricStatus(ref),
		"knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodAutoscaler":            schema_pkg_apis_autoscaling_v1alpha1_PodAutoscaler(ref),
		"knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodAutoscalerList":        schema_pkg_apis_autoscaling_v1alpha1_PodAutoscalerList(ref),
		"knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodAutoscalerSpec":        schema_pkg_apis_autoscaling_v1alpha1_PodAutoscalerSpec(ref),
		"knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodAutoscalerStatus":      schema_pkg_apis_autoscaling_v1alpha1_PodAutoscalerStatus(ref),
		"knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodScalable":              schema_pkg_apis_autoscaling_v1alpha1_PodScalable(ref),
		"knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodScalableList":          schema_pkg_apis_autoscaling_v1alpha1_PodScalableList(ref),
		"knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodScalableSpec":          schema_pkg_apis_autoscaling_v1alpha1_PodScalableSpec(ref),
		"knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodScalableStatus":        schema_pkg_apis_autoscaling_v1alpha1_PodScalableStatus(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.Certificate":               schema_pkg_apis_networking_v1alpha1_Certificate(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.CertificateList":           schema_pkg_apis_networking_v1alpha1_CertificateList(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.CertificateSpec":           schema_pkg_apis_networking_v1alpha1_CertificateSpec(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.CertificateStatus":         schema_pkg_apis_networking_v1alpha1_CertificateStatus(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.HTTP01Challenge":           schema_pkg_apis_networking_v1alpha1_HTTP01Challenge(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.HTTPIngressPath":           schema_pkg_apis_networking_v1alpha1_HTTPIngressPath(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.HTTPIngressRuleValue":      schema_pkg_apis_networking_v1alpha1_HTTPIngressRuleValue(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.HTTPRetry":                 schema_pkg_apis_networking_v1alpha1_HTTPRetry(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.Ingress":                   schema_pkg_apis_networking_v1alpha1_Ingress(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.IngressBackend":            schema_pkg_apis_networking_v1alpha1_IngressBackend(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.IngressBackendSplit":       schema_pkg_apis_networking_v1alpha1_IngressBackendSplit(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.IngressList":               schema_pkg_apis_networking_v1alpha1_IngressList(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.IngressRule":               schema_pkg_apis_networking_v1alpha1_IngressRule(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.IngressSpec":               schema_pkg_apis_networking_v1alpha1_IngressSpec(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.IngressStatus":             schema_pkg_apis_networking_v1alpha1_IngressStatus(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.IngressTLS":                schema_pkg_apis_networking_v1alpha1_IngressTLS(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.LoadBalancerIngressStatus": schema_pkg_apis_networking_v1alpha1_LoadBalancerIngressStatus(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.LoadBalancerStatus":        schema_pkg_apis_networking_v1alpha1_LoadBalancerStatus(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.ServerlessService":         schema_pkg_apis_networking_v1alpha1_ServerlessService(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.ServerlessServiceList":     schema_pkg_apis_networking_v1alpha1_ServerlessServiceList(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.ServerlessServiceSpec":     schema_pkg_apis_networking_v1alpha1_ServerlessServiceSpec(ref),
		"knative.dev/serving/pkg/apis/networking/v1alpha1.ServerlessServiceStatus":   schema_pkg_apis_networking_v1alpha1_ServerlessServiceStatus(ref),
		"knative.dev/serving/pkg/apis/serving/v1.AnnotationParseError":               schema_pkg_apis_serving_v1_AnnotationParseError(ref),
		"knative.dev/serving/pkg/apis/serving/v1.Configuration":                      schema_pkg_apis_serving_v1_Configuration(ref),
		"knative.dev/serving/pkg/apis/serving/v1.ConfigurationList":                  schema_pkg_apis_serving_v1_ConfigurationList(ref),
		"knative.dev/serving/pkg/apis/serving/v1.ConfigurationSpec":                  schema_pkg_apis_serving_v1_ConfigurationSpec(ref),
		"knative.dev/serving/pkg/apis/serving/v1.ConfigurationStatus":                schema_pkg_apis_serving_v1_ConfigurationStatus(ref),
		"knative.dev/serving/pkg/apis/serving/v1.ConfigurationStatusFields":          schema_pkg_apis_serving_v1_ConfigurationStatusFields(ref),
		"knative.dev/serving/pkg/apis/serving/v1.ContainerStatuses":                  schema_pkg_apis_serving_v1_ContainerStatuses(ref),
		"knative.dev/serving/pkg/apis/serving/v1.LastPinnedParseError":               schema_pkg_apis_serving_v1_LastPinnedParseError(ref),
		"knative.dev/serving/pkg/apis/serving/v1.Revision":                           schema_pkg_apis_serving_v1_Revision(ref),
		"knative.dev/serving/pkg/apis/serving/v1.RevisionList":                       schema_pkg_apis_serving_v1_RevisionList(ref),
		"knative.dev/serving/pkg/apis/serving/v1.RevisionSpec":                       schema_pkg_apis_serving_v1_RevisionSpec(ref),
		"knative.dev/serving/pkg/apis/serving/v1.RevisionStatus":                     schema_pkg_apis_serving_v1_RevisionStatus(ref),
		"knative.dev/serving/pkg/apis/serving/v1.RevisionTemplateSpec":               schema_pkg_apis_serving_v1_RevisionTemplateSpec(ref),
		"knative.dev/serving/pkg/apis/serving/v1.Route":                              schema_pkg_apis_serving_v1_Route(ref),
		"knative.dev/serving/pkg/apis/serving/v1.RouteList":                          schema_pkg_apis_serving_v1_RouteList(ref),
		"knative.dev/serving/pkg/apis/serving/v1.RouteSpec":                          schema_pkg_apis_serving_v1_RouteSpec(ref),
		"knative.dev/serving/pkg/apis/serving/v1.RouteStatus":                        schema_pkg_apis_serving_v1_RouteStatus(ref),
		"knative.dev/serving/pkg/apis/serving/v1.RouteStatusFields":                  schema_pkg_apis_serving_v1_RouteStatusFields(ref),
		"knative.dev/serving/pkg/apis/serving/v1.Service":                            schema_pkg_apis_serving_v1_Service(ref),
		"knative.dev/serving/pkg/apis/serving/v1.ServiceList":                        schema_pkg_apis_serving_v1_ServiceList(ref),
		"knative.dev/serving/pkg/apis/serving/v1.ServiceSpec":                        schema_pkg_apis_serving_v1_ServiceSpec(ref),
		"knative.dev/serving/pkg/apis/serving/v1.ServiceStatus":                      schema_pkg_apis_serving_v1_ServiceStatus(ref),
		"knative.dev/serving/pkg/apis/serving/v1.TrafficTarget":                      schema_pkg_apis_serving_v1_TrafficTarget(ref),
		"knative.dev/serving/pkg/apis/serving/v1.hdcnKey":                            schema_pkg_apis_serving_v1_hdcnKey(ref),
		"knative.dev/serving/pkg/apis/serving/v1.lemonadeKey":                        schema_pkg_apis_serving_v1_lemonadeKey(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.AnnotationParseError":         schema_pkg_apis_serving_v1alpha1_AnnotationParseError(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.CannotConvertError":           schema_pkg_apis_serving_v1alpha1_CannotConvertError(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.Configuration":                schema_pkg_apis_serving_v1alpha1_Configuration(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationList":            schema_pkg_apis_serving_v1alpha1_ConfigurationList(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationSpec":            schema_pkg_apis_serving_v1alpha1_ConfigurationSpec(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationStatus":          schema_pkg_apis_serving_v1alpha1_ConfigurationStatus(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationStatusFields":    schema_pkg_apis_serving_v1alpha1_ConfigurationStatusFields(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.ContainerStatuses":            schema_pkg_apis_serving_v1alpha1_ContainerStatuses(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.LastPinnedParseError":         schema_pkg_apis_serving_v1alpha1_LastPinnedParseError(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.ManualType":                   schema_pkg_apis_serving_v1alpha1_ManualType(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.PinnedType":                   schema_pkg_apis_serving_v1alpha1_PinnedType(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.ReleaseType":                  schema_pkg_apis_serving_v1alpha1_ReleaseType(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.Revision":                     schema_pkg_apis_serving_v1alpha1_Revision(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionList":                 schema_pkg_apis_serving_v1alpha1_RevisionList(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionSpec":                 schema_pkg_apis_serving_v1alpha1_RevisionSpec(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionStatus":               schema_pkg_apis_serving_v1alpha1_RevisionStatus(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionTemplateSpec":         schema_pkg_apis_serving_v1alpha1_RevisionTemplateSpec(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.Route":                        schema_pkg_apis_serving_v1alpha1_Route(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.RouteList":                    schema_pkg_apis_serving_v1alpha1_RouteList(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.RouteSpec":                    schema_pkg_apis_serving_v1alpha1_RouteSpec(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.RouteStatus":                  schema_pkg_apis_serving_v1alpha1_RouteStatus(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.RouteStatusFields":            schema_pkg_apis_serving_v1alpha1_RouteStatusFields(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.RunLatestType":                schema_pkg_apis_serving_v1alpha1_RunLatestType(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.Service":                      schema_pkg_apis_serving_v1alpha1_Service(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.ServiceList":                  schema_pkg_apis_serving_v1alpha1_ServiceList(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.ServiceSpec":                  schema_pkg_apis_serving_v1alpha1_ServiceSpec(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.ServiceStatus":                schema_pkg_apis_serving_v1alpha1_ServiceStatus(ref),
		"knative.dev/serving/pkg/apis/serving/v1alpha1.TrafficTarget":                schema_pkg_apis_serving_v1alpha1_TrafficTarget(ref),
		"knative.dev/serving/pkg/apis/serving/v1beta1.Configuration":                 schema_pkg_apis_serving_v1beta1_Configuration(ref),
		"knative.dev/serving/pkg/apis/serving/v1beta1.ConfigurationList":             schema_pkg_apis_serving_v1beta1_ConfigurationList(ref),
		"knative.dev/serving/pkg/apis/serving/v1beta1.Revision":                      schema_pkg_apis_serving_v1beta1_Revision(ref),
		"knative.dev/serving/pkg/apis/serving/v1beta1.RevisionList":                  schema_pkg_apis_serving_v1beta1_RevisionList(ref),
		"knative.dev/serving/pkg/apis/serving/v1beta1.Route":                         schema_pkg_apis_serving_v1beta1_Route(ref),
		"knative.dev/serving/pkg/apis/serving/v1beta1.RouteList":                     schema_pkg_apis_serving_v1beta1_RouteList(ref),
		"knative.dev/serving/pkg/apis/serving/v1beta1.Service":                       schema_pkg_apis_serving_v1beta1_Service(ref),
		"knative.dev/serving/pkg/apis/serving/v1beta1.ServiceList":                   schema_pkg_apis_serving_v1beta1_ServiceList(ref),
	}
}

func schema_knativedev_pkg_apis_Condition(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Conditions defines a readiness condition for a Knative resource. See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of condition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status of the condition, one of True, False, Unknown.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"severity": {
						SchemaProps: spec.SchemaProps{
							Description: "Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lastTransitionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).",
							Ref:         ref("knative.dev/pkg/apis.VolatileTime"),
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "The reason for the condition's last transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "A human readable message indicating details about the transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"type", "status"},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.VolatileTime"},
	}
}

func schema_knativedev_pkg_apis_ConditionSet(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConditionSet is an abstract collection of the possible ConditionType values that a particular resource might expose.  It also holds the \"happy condition\" for that resource, which we define to be one of Ready or Succeeded depending on whether it is a Living or Batch process respectively.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"happy": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"dependents": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
				},
				Required: []string{"happy", "dependents"},
			},
		},
	}
}

func schema_knativedev_pkg_apis_FieldError(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FieldError is used to propagate the context of errors pertaining to specific fields in a manner suitable for use in a recursive walk, so that errors contain the appropriate field context. FieldError methods are non-mutating.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"Message": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"Paths": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"Details": {
						SchemaProps: spec.SchemaProps{
							Description: "Details contains an optional longer payload.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"errors": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.FieldError"),
									},
								},
							},
						},
					},
				},
				Required: []string{"Message", "Paths", "errors"},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.FieldError"},
	}
}

func schema_knativedev_pkg_apis_URL(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "URL is an alias of url.URL. It has custom json marshal methods that enable it to be used in K8s CRDs such that the CRD resource will have the URL but operator code can can work with url.URL struct",
				Type:        apis.URL{}.OpenAPISchemaType(),
				Format:      apis.URL{}.OpenAPISchemaFormat(),
			},
		},
	}
}

func schema_knativedev_pkg_apis_VolatileTime(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "VolatileTime wraps metav1.Time\n\nUnlike metav1.Time, VolatileTimes are considered semantically equal when using kubernetes semantic equality checks. Thus differing VolatileTime values are not considered different. Note, go-cmp will still return inequality, see unit test if you need this behavior for go-cmp.",
				Type:        apis.VolatileTime{}.OpenAPISchemaType(),
				Format:      apis.VolatileTime{}.OpenAPISchemaFormat(),
			},
		},
	}
}

func schema_knativedev_pkg_apis_allowDifferentNamespace(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "This is attached to contexts as they are passed down through a resource being validated to direct them to allow namespaces (or missing namespace) outside the parent (as indicated by WithinParent.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_knativedev_pkg_apis_conditionsImpl(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "conditionsImpl implements the helper methods for evaluating Conditions.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"ConditionSet": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis.ConditionSet"),
						},
					},
					"accessor": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis.ConditionsAccessor"),
						},
					},
				},
				Required: []string{"ConditionSet", "accessor"},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.ConditionSet", "knative.dev/pkg/apis.ConditionsAccessor"},
	}
}

func schema_knativedev_pkg_apis_disallowDeprecated(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "This is attached to contexts as they are passed down through a resource being validated to direct them to disallow deprecated fields.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_knativedev_pkg_apis_inCreateKey(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "This is attached to contexts passed to webhook interfaces when the receiver being validated is being created.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_knativedev_pkg_apis_inDeleteKey(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "This is attached to contexts passed to webhook interfaces when the receiver being validated is being deleted.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_knativedev_pkg_apis_inSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "This is attached to contexts as they are passed down through a resource being validated or defaulted to signal that we are within a Spec.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_knativedev_pkg_apis_inStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "This is attached to contexts as they are passed down through a resource being validated or defaulted to signal that we are within a Status.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_knativedev_pkg_apis_inUpdateKey(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "This is attached to contexts passed to webhook interfaces when the receiver being validated is being updated.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_knativedev_pkg_apis_isDryRun(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "This is attached to contexts passed to webhook interfaces when the user has request DryRun mode.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_knativedev_pkg_apis_parentMetaKey(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "This is attached to contexts as they are passed down through a resource being validated or defaulted to signal the ObjectMeta of the enclosing resource.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_knativedev_pkg_apis_updatePayload(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"base": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"object"},
							Format: "",
						},
					},
					"subresource": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
				Required: []string{"base", "subresource"},
			},
		},
	}
}

func schema_knativedev_pkg_apis_userInfoKey(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "This is attached to contexts passed to webhook interfaces when the receiver being validated is being created.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_pkg_apis_duck_v1_AddressStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AddressStatus shows how we expect folks to embed Addressable in their Status field.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"address": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1.Addressable"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis/duck/v1.Addressable"},
	}
}

func schema_pkg_apis_duck_v1_Addressable(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Addressable provides a generic mechanism for a custom resource definition to indicate a destination for message delivery.\n\nAddressable is the schema for the destination information. This is typically stored in the object's `status`, as this information may be generated by the controller.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis.URL"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.URL"},
	}
}

func schema_pkg_apis_duck_v1_AddressableType(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AddressableType is a skeleton type wrapping Addressable in the manner we expect resource writers defining compatible resources to embed it.  We will typically use this type to deserialize Addressable ObjectReferences and access the Addressable data.  This is not a real resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1.AddressStatus"),
						},
					},
				},
				Required: []string{"status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/pkg/apis/duck/v1.AddressStatus"},
	}
}

func schema_pkg_apis_duck_v1_AddressableTypeList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AddressableTypeList is a list of AddressableType resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis/duck/v1.AddressableType"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/pkg/apis/duck/v1.AddressableType"},
	}
}

func schema_pkg_apis_duck_v1_CloudEventAttributes(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CloudEventAttributes specifies the attributes that a Source uses as part of its CloudEvents.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type refers to the CloudEvent type attribute.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"source": {
						SchemaProps: spec.SchemaProps{
							Description: "Source is the CloudEvents source attribute.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_duck_v1_CloudEventOverrides(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CloudEventOverrides defines arguments for a Source that control the output format of the CloudEvents produced by the Source.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"extensions": {
						SchemaProps: spec.SchemaProps{
							Description: "Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_duck_v1_Destination(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Destination represents a target of an invocation over HTTP.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"ref": {
						SchemaProps: spec.SchemaProps{
							Description: "Ref points to an Addressable.",
							Ref:         ref("knative.dev/pkg/apis/duck/v1.KReference"),
						},
					},
					"uri": {
						SchemaProps: spec.SchemaProps{
							Description: "URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.URL", "knative.dev/pkg/apis/duck/v1.KReference"},
	}
}

func schema_pkg_apis_duck_v1_KReference(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "KReference contains enough information to refer to another object. It's a trimmed down version of corev1.ObjectReference.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "API version of the referent.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"kind", "name", "apiVersion"},
			},
		},
	}
}

func schema_pkg_apis_duck_v1_KResource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "KResource is a skeleton type wrapping Conditions in the manner we expect resource writers defining compatible resources to embed it.  We will typically use this type to deserialize Conditions ObjectReferences and access the Conditions data.  This is not a real resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1.Status"),
						},
					},
				},
				Required: []string{"status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/pkg/apis/duck/v1.Status"},
	}
}

func schema_pkg_apis_duck_v1_KResourceList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "KResourceList is a list of KResource resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis/duck/v1.KResource"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/pkg/apis/duck/v1.KResource"},
	}
}

func schema_pkg_apis_duck_v1_PodSpecable(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodSpecable is implemented by types containing a PodTemplateSpec in the manner of ReplicaSet, Deployment, DaemonSet, StatefulSet.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
							Ref:         ref("k8s.io/api/core/v1.PodSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.PodSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_duck_v1_Source(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Source is the minimum resource shape to adhere to the Source Specification. This duck type is intended to allow implementors of Sources and Importers to verify their own resources meet the expectations. This is not a real resource. NOTE: The Source Specification is in progress and the shape and names could be modified until it has been accepted.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1.SourceSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1.SourceStatus"),
						},
					},
				},
				Required: []string{"spec", "status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/pkg/apis/duck/v1.SourceSpec", "knative.dev/pkg/apis/duck/v1.SourceStatus"},
	}
}

func schema_pkg_apis_duck_v1_SourceList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SourceList is a list of Source resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis/duck/v1.Source"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/pkg/apis/duck/v1.Source"},
	}
}

func schema_pkg_apis_duck_v1_SourceSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"sink": {
						SchemaProps: spec.SchemaProps{
							Description: "Sink is a reference to an object that will resolve to a uri to use as the sink.",
							Ref:         ref("knative.dev/pkg/apis/duck/v1.Destination"),
						},
					},
					"ceOverrides": {
						SchemaProps: spec.SchemaProps{
							Description: "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
							Ref:         ref("knative.dev/pkg/apis/duck/v1.CloudEventOverrides"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis/duck/v1.CloudEventOverrides", "knative.dev/pkg/apis/duck/v1.Destination"},
	}
}

func schema_pkg_apis_duck_v1_SourceStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SourceStatus shows how we expect folks to embed Addressable in their Status field.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"sinkUri": {
						SchemaProps: spec.SchemaProps{
							Description: "SinkURI is the current active sink URI that has been configured for the Source.",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
					"ceAttributes": {
						SchemaProps: spec.SchemaProps{
							Description: "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis/duck/v1.CloudEventAttributes"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition", "knative.dev/pkg/apis.URL", "knative.dev/pkg/apis/duck/v1.CloudEventAttributes"},
	}
}

func schema_pkg_apis_duck_v1_Status(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Status shows how we expect folks to embed Conditions in their Status field. WARNING: Adding fields to this struct will add them to all Knative resources.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition"},
	}
}

func schema_pkg_apis_duck_v1_WithPod(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WithPod is the shell that demonstrates how PodSpecable types wrap a PodSpec.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1.WithPodSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/pkg/apis/duck/v1.WithPodSpec"},
	}
}

func schema_pkg_apis_duck_v1_WithPodList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WithPodList is a list of WithPod resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis/duck/v1.WithPod"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/pkg/apis/duck/v1.WithPod"},
	}
}

func schema_pkg_apis_duck_v1_WithPodSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WithPodSpec is the shell around the PodSpecable within WithPod.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"template": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1.PodSpecable"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis/duck/v1.PodSpecable"},
	}
}

func schema_pkg_apis_duck_v1alpha1_AddressStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AddressStatus shows how we expect folks to embed Addressable in their Status field.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"address": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1alpha1.Addressable"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis/duck/v1alpha1.Addressable"},
	}
}

func schema_pkg_apis_duck_v1alpha1_Addressable(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Addressable provides a generic mechanism for a custom resource definition to indicate a destination for message delivery.\n\nAddressable is the schema for the destination information. This is typically stored in the object's `status`, as this information may be generated by the controller.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"hostname": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_duck_v1alpha1_AddressableType(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AddressableType is a skeleton type wrapping Addressable in the manner we expect resource writers defining compatible resources to embed it.  We will typically use this type to deserialize Addressable ObjectReferences and access the Addressable data.  This is not a real resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1alpha1.AddressStatus"),
						},
					},
				},
				Required: []string{"status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/pkg/apis/duck/v1alpha1.AddressStatus"},
	}
}

func schema_pkg_apis_duck_v1alpha1_AddressableTypeList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AddressableTypeList is a list of AddressableType resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis/duck/v1alpha1.AddressableType"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/pkg/apis/duck/v1alpha1.AddressableType"},
	}
}

func schema_pkg_apis_duck_v1alpha1_Binding(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Binding is a duck type that specifies the partial schema to which all Binding implementations should adhere.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1alpha1.BindingSpec"),
						},
					},
				},
				Required: []string{"spec"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/pkg/apis/duck/v1alpha1.BindingSpec"},
	}
}

func schema_pkg_apis_duck_v1alpha1_BindingList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BindingList is a list of Binding resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis/duck/v1alpha1.Binding"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/pkg/apis/duck/v1alpha1.Binding"},
	}
}

func schema_pkg_apis_duck_v1alpha1_BindingSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BindingSpec specifies the spec portion of the Binding partial-schema.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"subject": {
						SchemaProps: spec.SchemaProps{
							Description: "Subject references the resource(s) whose \"runtime contract\" should be augmented by Binding implementations.",
							Ref:         ref("knative.dev/pkg/tracker.Reference"),
						},
					},
				},
				Required: []string{"subject"},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/tracker.Reference"},
	}
}

func schema_pkg_apis_duck_v1alpha1_LegacyTarget(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "LegacyTarget is a skeleton type wrapping LegacyTargetable in the manner we want to support unless they get migrated into supporting Legacy. We will typically use this type to deserialize LegacyTargetable ObjectReferences and access the LegacyTargetable data.  This is not a real resource. ** Do not use this for any new resources **",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1alpha1.LegacyTargetable"),
						},
					},
				},
				Required: []string{"status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/pkg/apis/duck/v1alpha1.LegacyTargetable"},
	}
}

func schema_pkg_apis_duck_v1alpha1_LegacyTargetList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "LegacyTargetList is a list of LegacyTarget resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis/duck/v1alpha1.LegacyTarget"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/pkg/apis/duck/v1alpha1.LegacyTarget"},
	}
}

func schema_pkg_apis_duck_v1alpha1_LegacyTargetable(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "LegacyTargetable left around until we migrate to Addressable in the dependent resources. Addressable has more structure in the way it defines the fields. LegacyTargetable only assumed a single string in the Status field and we're moving towards defining proper structs under Status rather than strings. This is to support existing resources until they migrate.\n\nDo not use this for anything new, use Addressable\n\nLegacyTargetable is the old schema for the addressable portion of the payload\n\nFor new resources use Addressable.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"domainInternal": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_duck_v1alpha1_Target(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Target is a skeleton type wrapping Targetable in the manner we expect resource writers defining compatible resources to embed it.  We will typically use this type to deserialize Targetable ObjectReferences and access the Targetable data.  This is not a real resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1alpha1.TargetStatus"),
						},
					},
				},
				Required: []string{"status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/pkg/apis/duck/v1alpha1.TargetStatus"},
	}
}

func schema_pkg_apis_duck_v1alpha1_TargetList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TargetList is a list of Target resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis/duck/v1alpha1.Target"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/pkg/apis/duck/v1alpha1.Target"},
	}
}

func schema_pkg_apis_duck_v1alpha1_TargetStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TargetStatus shows how we expect folks to embed Targetable in their Status field.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"targetable": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1alpha1.Targetable"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis/duck/v1alpha1.Targetable"},
	}
}

func schema_pkg_apis_duck_v1alpha1_Targetable(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Targetable is an earlier version of the Callable interface. Callable is a higher-level interface which implements Addressable but further promises that the destination may synchronously return response messages in reply to a message.\n\nTargetable implementations should instead implement Addressable and include an `eventing.knative.dev/returns=any` annotation.\n\nTargetable is retired; implement Addressable for now.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"domainInternal": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_duck_v1beta1_AddressStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AddressStatus shows how we expect folks to embed Addressable in their Status field.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"address": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1beta1.Addressable"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis/duck/v1beta1.Addressable"},
	}
}

func schema_pkg_apis_duck_v1beta1_Addressable(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Addressable provides a generic mechanism for a custom resource definition to indicate a destination for message delivery.\n\nAddressable is the schema for the destination information. This is typically stored in the object's `status`, as this information may be generated by the controller.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis.URL"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.URL"},
	}
}

func schema_pkg_apis_duck_v1beta1_AddressableType(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AddressableType is a skeleton type wrapping Addressable in the manner we expect resource writers defining compatible resources to embed it.  We will typically use this type to deserialize Addressable ObjectReferences and access the Addressable data.  This is not a real resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1beta1.AddressStatus"),
						},
					},
				},
				Required: []string{"status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/pkg/apis/duck/v1beta1.AddressStatus"},
	}
}

func schema_pkg_apis_duck_v1beta1_AddressableTypeList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AddressableTypeList is a list of AddressableType resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis/duck/v1beta1.AddressableType"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/pkg/apis/duck/v1beta1.AddressableType"},
	}
}

func schema_pkg_apis_duck_v1beta1_CloudEventOverrides(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CloudEventOverrides defines arguments for a Source that control the output format of the CloudEvents produced by the Source.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"extensions": {
						SchemaProps: spec.SchemaProps{
							Description: "Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_duck_v1beta1_Destination(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Destination represents a target of an invocation over HTTP.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"ref": {
						SchemaProps: spec.SchemaProps{
							Description: "Ref points to an Addressable.",
							Ref:         ref("k8s.io/api/core/v1.ObjectReference"),
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"uri": {
						SchemaProps: spec.SchemaProps{
							Description: "URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ObjectReference", "knative.dev/pkg/apis.URL"},
	}
}

func schema_pkg_apis_duck_v1beta1_KResource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "KResource is a skeleton type wrapping Conditions in the manner we expect resource writers defining compatible resources to embed it.  We will typically use this type to deserialize Conditions ObjectReferences and access the Conditions data.  This is not a real resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1beta1.Status"),
						},
					},
				},
				Required: []string{"status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/pkg/apis/duck/v1beta1.Status"},
	}
}

func schema_pkg_apis_duck_v1beta1_KResourceList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "KResourceList is a list of KResource resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis/duck/v1beta1.KResource"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/pkg/apis/duck/v1beta1.KResource"},
	}
}

func schema_pkg_apis_duck_v1beta1_Source(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Source is the minimum resource shape to adhere to the Source Specification. This duck type is intended to allow implementors of Sources and Importers to verify their own resources meet the expectations. This is not a real resource. NOTE: The Source Specification is in progress and the shape and names could be modified until it has been accepted.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1beta1.SourceSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/pkg/apis/duck/v1beta1.SourceStatus"),
						},
					},
				},
				Required: []string{"spec", "status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/pkg/apis/duck/v1beta1.SourceSpec", "knative.dev/pkg/apis/duck/v1beta1.SourceStatus"},
	}
}

func schema_pkg_apis_duck_v1beta1_SourceList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SourceList is a list of Source resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis/duck/v1beta1.Source"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/pkg/apis/duck/v1beta1.Source"},
	}
}

func schema_pkg_apis_duck_v1beta1_SourceSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"sink": {
						SchemaProps: spec.SchemaProps{
							Description: "Sink is a reference to an object that will resolve to a domain name or a URI directly to use as the sink.",
							Ref:         ref("knative.dev/pkg/apis/duck/v1beta1.Destination"),
						},
					},
					"ceOverrides": {
						SchemaProps: spec.SchemaProps{
							Description: "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
							Ref:         ref("knative.dev/pkg/apis/duck/v1beta1.CloudEventOverrides"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis/duck/v1beta1.CloudEventOverrides", "knative.dev/pkg/apis/duck/v1beta1.Destination"},
	}
}

func schema_pkg_apis_duck_v1beta1_SourceStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SourceStatus shows how we expect folks to embed Addressable in their Status field.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"sinkUri": {
						SchemaProps: spec.SchemaProps{
							Description: "SinkURI is the current active sink URI that has been configured for the Source.",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition", "knative.dev/pkg/apis.URL"},
	}
}

func schema_pkg_apis_duck_v1beta1_Status(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Status shows how we expect folks to embed Conditions in their Status field. WARNING: Adding fields to this struct will add them to all Knative resources.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition"},
	}
}

func schema_pkg_apis_autoscaling_v1alpha1_Metric(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Metric represents a resource to configure the metric collector with.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Spec holds the desired state of the Metric (from the client).",
							Ref:         ref("knative.dev/serving/pkg/apis/autoscaling/v1alpha1.MetricSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status communicates the observed state of the Metric (from the controller).",
							Ref:         ref("knative.dev/serving/pkg/apis/autoscaling/v1alpha1.MetricStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/autoscaling/v1alpha1.MetricSpec", "knative.dev/serving/pkg/apis/autoscaling/v1alpha1.MetricStatus"},
	}
}

func schema_pkg_apis_autoscaling_v1alpha1_MetricList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MetricList is a list of Metric resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/autoscaling/v1alpha1.Metric"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/autoscaling/v1alpha1.Metric"},
	}
}

func schema_pkg_apis_autoscaling_v1alpha1_MetricSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MetricSpec contains all values a metric collector needs to operate.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"stableWindow": {
						SchemaProps: spec.SchemaProps{
							Description: "StableWindow is the aggregation window for metrics in a stable state.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"panicWindow": {
						SchemaProps: spec.SchemaProps{
							Description: "PanicWindow is the aggregation window for metrics where quick reactions are needed.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"scrapeTarget": {
						SchemaProps: spec.SchemaProps{
							Description: "ScrapeTarget is the K8s service that publishes the metric endpoint.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"stableWindow", "panicWindow", "scrapeTarget"},
			},
		},
	}
}

func schema_pkg_apis_autoscaling_v1alpha1_MetricStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MetricStatus reflects the status of metric collection for this specific entity.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition"},
	}
}

func schema_pkg_apis_autoscaling_v1alpha1_PodAutoscaler(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodAutoscaler is a Knative abstraction that encapsulates the interface by which Knative components instantiate autoscalers.  This definition is an abstraction that may be backed by multiple definitions.  For more information, see the Knative Pluggability presentation: https://docs.google.com/presentation/d/10KWynvAJYuOEWy69VBa6bHJVCqIsz1TNdEKosNvcpPY/edit",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Spec holds the desired state of the PodAutoscaler (from the client).",
							Ref:         ref("knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodAutoscalerSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status communicates the observed state of the PodAutoscaler (from the controller).",
							Ref:         ref("knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodAutoscalerStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodAutoscalerSpec", "knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodAutoscalerStatus"},
	}
}

func schema_pkg_apis_autoscaling_v1alpha1_PodAutoscalerList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodAutoscalerList is a list of PodAutoscaler resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodAutoscaler"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodAutoscaler"},
	}
}

func schema_pkg_apis_autoscaling_v1alpha1_PodAutoscalerSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodAutoscalerSpec holds the desired state of the PodAutoscaler (from the client).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"generation": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedGeneration was used prior in Kubernetes versions <1.11 when metadata.generation was not being incremented by the api server\n\nThis property will be dropped in future Knative releases and should not be used - use metadata.generation\n\nTracking issue: https://github.com/knative/serving/issues/643",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"containerConcurrency": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerConcurrency specifies the maximum allowed in-flight (concurrent) requests per container of the Revision. Defaults to `0` which means unlimited concurrency.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"scaleTargetRef": {
						SchemaProps: spec.SchemaProps{
							Description: "ScaleTargetRef defines the /scale-able resource that this PodAutoscaler is responsible for quickly right-sizing.",
							Ref:         ref("k8s.io/api/core/v1.ObjectReference"),
						},
					},
					"reachability": {
						SchemaProps: spec.SchemaProps{
							Description: "Reachable specifies whether or not the `ScaleTargetRef` can be reached (ie. has a route). Defaults to `ReachabilityUnknown`",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"protocolType": {
						SchemaProps: spec.SchemaProps{
							Description: "The application-layer protocol. Matches `ProtocolType` inferred from the revision spec.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"scaleTargetRef", "protocolType"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ObjectReference"},
	}
}

func schema_pkg_apis_autoscaling_v1alpha1_PodAutoscalerStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodAutoscalerStatus communicates the observed state of the PodAutoscaler (from the controller).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"serviceName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceName is the K8s Service name that serves the revision, scaled by this PA. The service is created and owned by the ServerlessService object owned by this PA.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metricsServiceName": {
						SchemaProps: spec.SchemaProps{
							Description: "MetricsServiceName is the K8s Service name that provides revision metrics. The service is managed by the PA object.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"desiredScale": {
						SchemaProps: spec.SchemaProps{
							Description: "DesiredScale shows the current desired number of replicas for the revision.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"actualScale": {
						SchemaProps: spec.SchemaProps{
							Description: "ActualScale shows the actual number of replicas for the revision.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"serviceName", "metricsServiceName"},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition"},
	}
}

func schema_pkg_apis_autoscaling_v1alpha1_PodScalable(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodScalable is a duck type that the resources referenced by the PodAutoscaler's ScaleTargetRef must implement.  They must also implement the `/scale` sub-resource for use with `/scale` based implementations (e.g. HPA), but this further constrains the shape the referenced resources may take.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodScalableSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodScalableStatus"),
						},
					},
				},
				Required: []string{"spec", "status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodScalableSpec", "knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodScalableStatus"},
	}
}

func schema_pkg_apis_autoscaling_v1alpha1_PodScalableList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodScalableList is a list of PodScalable resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodScalable"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/autoscaling/v1alpha1.PodScalable"},
	}
}

func schema_pkg_apis_autoscaling_v1alpha1_PodScalableSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodScalableSpec is the specification for the desired state of a PodScalable (or at least our shared portion).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"integer"},
							Format: "int32",
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"template": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/api/core/v1.PodTemplateSpec"),
						},
					},
				},
				Required: []string{"selector", "template"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.PodTemplateSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_pkg_apis_autoscaling_v1alpha1_PodScalableStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodScalableStatus is the observed state of a PodScalable (or at least our shared portion).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"integer"},
							Format: "int32",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_networking_v1alpha1_Certificate(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Certificate is responsible for provisioning a SSL certificate for the given hosts. It is a Knative abstraction for various SSL certificate provisioning solutions (such as cert-manager or self-signed SSL certificate).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Spec is the desired state of the Certificate. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
							Ref:         ref("knative.dev/serving/pkg/apis/networking/v1alpha1.CertificateSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status is the current state of the Certificate. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
							Ref:         ref("knative.dev/serving/pkg/apis/networking/v1alpha1.CertificateStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/networking/v1alpha1.CertificateSpec", "knative.dev/serving/pkg/apis/networking/v1alpha1.CertificateStatus"},
	}
}

func schema_pkg_apis_networking_v1alpha1_CertificateList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CertificateList is a collection of `Certificate`.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Description: "Items is the list of `Certificate`.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/networking/v1alpha1.Certificate"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/networking/v1alpha1.Certificate"},
	}
}

func schema_pkg_apis_networking_v1alpha1_CertificateSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CertificateSpec defines the desired state of a `Certificate`.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"dnsNames": {
						SchemaProps: spec.SchemaProps{
							Description: "DNSNames is a list of DNS names the Certificate could support. The wildcard format of DNSNames (e.g. *.default.example.com) is supported.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"secretName": {
						SchemaProps: spec.SchemaProps{
							Description: "SecretName is the name of the secret resource to store the SSL certificate in.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"dnsNames", "secretName"},
			},
		},
	}
}

func schema_pkg_apis_networking_v1alpha1_CertificateStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CertificateStatus defines the observed state of a `Certificate`.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"notAfter": {
						SchemaProps: spec.SchemaProps{
							Description: "The expiration time of the TLS certificate stored in the secret named by this resource in spec.secretName.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"http01Challenges": {
						SchemaProps: spec.SchemaProps{
							Description: "HTTP01Challenges is a list of HTTP01 challenges that need to be fulfilled in order to get the TLS certificate..",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/networking/v1alpha1.HTTP01Challenge"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time", "knative.dev/pkg/apis.Condition", "knative.dev/serving/pkg/apis/networking/v1alpha1.HTTP01Challenge"},
	}
}

func schema_pkg_apis_networking_v1alpha1_HTTP01Challenge(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HTTP01Challenge defines the status of a HTTP01 challenge that a certificate needs to fulfill.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL is the URL that the HTTP01 challenge is expected to serve on.",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
					"serviceName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceName is the name of the service to serve HTTP01 challenge requests.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceNamespace is the namespace of the service to serve HTTP01 challenge requests.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"servicePort": {
						SchemaProps: spec.SchemaProps{
							Description: "ServicePort is the port of the service to serve HTTP01 challenge requests.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/util/intstr.IntOrString", "knative.dev/pkg/apis.URL"},
	}
}

func schema_pkg_apis_networking_v1alpha1_HTTPIngressPath(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HTTPIngressPath associates a path regex with a backend. Incoming URLs matching the path are forwarded to the backend.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. Paths must begin with a '/'. If unspecified, the path defaults to a catch all sending traffic to the backend.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"splits": {
						SchemaProps: spec.SchemaProps{
							Description: "Splits defines the referenced service endpoints to which the traffic will be forwarded to.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/networking/v1alpha1.IngressBackendSplit"),
									},
								},
							},
						},
					},
					"appendHeaders": {
						SchemaProps: spec.SchemaProps{
							Description: "AppendHeaders allow specifying additional HTTP headers to add before forwarding a request to the destination service.\n\nNOTE: This differs from K8s Ingress which doesn't allow header appending.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"timeout": {
						SchemaProps: spec.SchemaProps{
							Description: "Timeout for HTTP requests.\n\nNOTE: This differs from K8s Ingress which doesn't allow setting timeouts.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
					"retries": {
						SchemaProps: spec.SchemaProps{
							Description: "Retry policy for HTTP requests.\n\nNOTE: This differs from K8s Ingress which doesn't allow retry settings.",
							Ref:         ref("knative.dev/serving/pkg/apis/networking/v1alpha1.HTTPRetry"),
						},
					},
				},
				Required: []string{"splits"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Duration", "knative.dev/serving/pkg/apis/networking/v1alpha1.HTTPRetry", "knative.dev/serving/pkg/apis/networking/v1alpha1.IngressBackendSplit"},
	}
}

func schema_pkg_apis_networking_v1alpha1_HTTPIngressRuleValue(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example: http://<host>/<path>?<searchpart> -> backend where where parts of the url correspond to RFC 3986, this resource will be used to match against everything after the last '/' and before the first '?' or '#'.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"paths": {
						SchemaProps: spec.SchemaProps{
							Description: "A collection of paths that map requests to backends.\n\nIf they are multiple matching paths, the first match takes precendent.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/networking/v1alpha1.HTTPIngressPath"),
									},
								},
							},
						},
					},
				},
				Required: []string{"paths"},
			},
		},
		Dependencies: []string{
			"knative.dev/serving/pkg/apis/networking/v1alpha1.HTTPIngressPath"},
	}
}

func schema_pkg_apis_networking_v1alpha1_HTTPRetry(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HTTPRetry describes the retry policy to use when a HTTP request fails.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"attempts": {
						SchemaProps: spec.SchemaProps{
							Description: "Number of retries for a given request.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"perTryTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "Timeout per retry attempt for a given request. format: 1h/1m/1s/1ms. MUST BE >=1ms.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
				},
				Required: []string{"attempts", "perTryTimeout"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_networking_v1alpha1_Ingress(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable URLs, load balance traffic, offer name based virtual hosting, etc.\n\nThis is heavily based on K8s Ingress https://godoc.org/k8s.io/api/networking/v1beta1#Ingress which some highlighted modifications.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Spec is the desired state of the Ingress. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
							Ref:         ref("knative.dev/serving/pkg/apis/networking/v1alpha1.IngressSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status is the current state of the Ingress. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
							Ref:         ref("knative.dev/serving/pkg/apis/networking/v1alpha1.IngressStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/networking/v1alpha1.IngressSpec", "knative.dev/serving/pkg/apis/networking/v1alpha1.IngressStatus"},
	}
}

func schema_pkg_apis_networking_v1alpha1_IngressBackend(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "IngressBackend describes all endpoints for a given service and port.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"serviceNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the namespace of the referenced service.\n\nNOTE: This differs from K8s Ingress to allow routing to different namespaces.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceName": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the name of the referenced service.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"servicePort": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the port of the referenced service.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
				},
				Required: []string{"serviceNamespace", "serviceName", "servicePort"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_pkg_apis_networking_v1alpha1_IngressBackendSplit(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "IngressBackendSplit describes all endpoints for a given service and port.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"serviceNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the namespace of the referenced service.\n\nNOTE: This differs from K8s Ingress to allow routing to different namespaces.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceName": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the name of the referenced service.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"servicePort": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the port of the referenced service.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"percent": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the split percentage, a number between 0 and 100.  If only one split is specified, we default to 100.\n\nNOTE: This differs from K8s Ingress to allow percentage split.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"appendHeaders": {
						SchemaProps: spec.SchemaProps{
							Description: "AppendHeaders allow specifying additional HTTP headers to add before forwarding a request to the destination service.\n\nNOTE: This differs from K8s Ingress which doesn't allow header appending.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
				},
				Required: []string{"serviceNamespace", "serviceName", "servicePort"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_pkg_apis_networking_v1alpha1_IngressList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "IngressList is a collection of Ingress objects.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard object metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Description: "Items is the list of Ingress objects.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/networking/v1alpha1.Ingress"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/networking/v1alpha1.Ingress"},
	}
}

func schema_pkg_apis_networking_v1alpha1_IngressRule(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "IngressRule represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching IngressRuleValue.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"hosts": {
						SchemaProps: spec.SchemaProps{
							Description: "Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \"host\" part of the URI as defined in the RFC: 1. IPs are not allowed. Currently a rule value can only apply to the\n\t  IP in the Spec of the parent .\n2. The `:` delimiter is not respected because ports are not allowed.\n\t  Currently the port of an Ingress is implicitly :80 for http and\n\t  :443 for https.\nBoth these may change in the future. If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. If multiple matching Hosts were provided, the first rule will take precedent.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"visibility": {
						SchemaProps: spec.SchemaProps{
							Description: "Visibility signifies whether this rule should `ClusterLocal`. If it's not specified then it defaults to `ExternalIP`.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"http": {
						SchemaProps: spec.SchemaProps{
							Description: "HTTP represents a rule to apply against incoming requests. If the rule is satisfied, the request is routed to the specified backend.",
							Ref:         ref("knative.dev/serving/pkg/apis/networking/v1alpha1.HTTPIngressRuleValue"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/serving/pkg/apis/networking/v1alpha1.HTTPIngressRuleValue"},
	}
}

func schema_pkg_apis_networking_v1alpha1_IngressSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "IngressSpec describes the Ingress the user wishes to exist.\n\nIn general this follows the same shape as K8s Ingress. Some notable differences: - Backends now can have namespace: - Traffic can be split across multiple backends. - Timeout & Retry can be configured. - Headers can be appended.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"generation": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedGeneration was used prior in Kubernetes versions <1.11 when metadata.generation was not being incremented by the api server\n\nThis property will be dropped in future Knative releases and should not be used - use metadata.generation\n\nTracking issue: https://github.com/knative/serving/issues/643",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"tls": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS configuration. Currently Ingress only supports a single TLS port: 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/networking/v1alpha1.IngressTLS"),
									},
								},
							},
						},
					},
					"rules": {
						SchemaProps: spec.SchemaProps{
							Description: "A list of host rules used to configure the Ingress.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/networking/v1alpha1.IngressRule"),
									},
								},
							},
						},
					},
					"visibility": {
						SchemaProps: spec.SchemaProps{
							Description: "Visibility setting.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/serving/pkg/apis/networking/v1alpha1.IngressRule", "knative.dev/serving/pkg/apis/networking/v1alpha1.IngressTLS"},
	}
}

func schema_pkg_apis_networking_v1alpha1_IngressStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "IngressStatus describe the current state of the Ingress.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"loadBalancer": {
						SchemaProps: spec.SchemaProps{
							Description: "LoadBalancer contains the current status of the load-balancer. This is to be superseded by the combination of `PublicLoadBalancer` and `PrivateLoadBalancer`",
							Ref:         ref("knative.dev/serving/pkg/apis/networking/v1alpha1.LoadBalancerStatus"),
						},
					},
					"publicLoadBalancer": {
						SchemaProps: spec.SchemaProps{
							Description: "PublicLoadBalancer contains the current status of the load-balancer.",
							Ref:         ref("knative.dev/serving/pkg/apis/networking/v1alpha1.LoadBalancerStatus"),
						},
					},
					"privateLoadBalancer": {
						SchemaProps: spec.SchemaProps{
							Description: "PrivateLoadBalancer contains the current status of the load-balancer.",
							Ref:         ref("knative.dev/serving/pkg/apis/networking/v1alpha1.LoadBalancerStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition", "knative.dev/serving/pkg/apis/networking/v1alpha1.LoadBalancerStatus"},
	}
}

func schema_pkg_apis_networking_v1alpha1_IngressTLS(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "IngressTLS describes the transport layer security associated with an Ingress.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"hosts": {
						SchemaProps: spec.SchemaProps{
							Description: "Hosts is a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the tlsSecret. Defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress, if left unspecified.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"secretName": {
						SchemaProps: spec.SchemaProps{
							Description: "SecretName is the name of the secret used to terminate SSL traffic.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"secretNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "SecretNamespace is the namespace of the secret used to terminate SSL traffic.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serverCertificate": {
						SchemaProps: spec.SchemaProps{
							Description: "ServerCertificate identifies the certificate filename in the secret. Defaults to `tls.crt`.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"privateKey": {
						SchemaProps: spec.SchemaProps{
							Description: "PrivateKey identifies the private key filename in the secret. Defaults to `tls.key`.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_networking_v1alpha1_LoadBalancerIngressStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "LoadBalancerIngressStatus represents the status of a load-balancer ingress point: traffic intended for the service should be sent to an ingress point.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"ip": {
						SchemaProps: spec.SchemaProps{
							Description: "IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack load-balancers)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"domain": {
						SchemaProps: spec.SchemaProps{
							Description: "Domain is set for load-balancer ingress points that are DNS based (typically AWS load-balancers)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"domainInternal": {
						SchemaProps: spec.SchemaProps{
							Description: "DomainInternal is set if there is a cluster-local DNS name to access the Ingress.\n\nNOTE: This differs from K8s Ingress, since we also desire to have a cluster-local\n      DNS name to allow routing in case of not having a mesh.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"meshOnly": {
						SchemaProps: spec.SchemaProps{
							Description: "MeshOnly is set if the Ingress is only load-balanced through a Service mesh.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_networking_v1alpha1_LoadBalancerStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "LoadBalancerStatus represents the status of a load-balancer.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"ingress": {
						SchemaProps: spec.SchemaProps{
							Description: "Ingress is a list containing ingress points for the load-balancer. Traffic intended for the service should be sent to these ingress points.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/networking/v1alpha1.LoadBalancerIngressStatus"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/serving/pkg/apis/networking/v1alpha1.LoadBalancerIngressStatus"},
	}
}

func schema_pkg_apis_networking_v1alpha1_ServerlessService(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServerlessService is a proxy for the K8s service objects containing the endpoints for the revision, whether those are endpoints of the activator or revision pods. See: https://knative.page.link/naxz for details.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Spec is the desired state of the ServerlessService. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
							Ref:         ref("knative.dev/serving/pkg/apis/networking/v1alpha1.ServerlessServiceSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status is the current state of the ServerlessService. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
							Ref:         ref("knative.dev/serving/pkg/apis/networking/v1alpha1.ServerlessServiceStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/networking/v1alpha1.ServerlessServiceSpec", "knative.dev/serving/pkg/apis/networking/v1alpha1.ServerlessServiceStatus"},
	}
}

func schema_pkg_apis_networking_v1alpha1_ServerlessServiceList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServerlessServiceList is a collection of ServerlessService.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Description: "Items is the list of ServerlessService.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/networking/v1alpha1.ServerlessService"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/networking/v1alpha1.ServerlessService"},
	}
}

func schema_pkg_apis_networking_v1alpha1_ServerlessServiceSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServerlessServiceSpec describes the ServerlessService.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"mode": {
						SchemaProps: spec.SchemaProps{
							Description: "Mode describes the mode of operation of the ServerlessService.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"objectRef": {
						SchemaProps: spec.SchemaProps{
							Description: "ObjectRef defines the resource that this ServerlessService is responsible for making \"serverless\".",
							Ref:         ref("k8s.io/api/core/v1.ObjectReference"),
						},
					},
					"ProtocolType": {
						SchemaProps: spec.SchemaProps{
							Description: "The application-layer protocol. Matches `RevisionProtocolType` set on the owning pa/revision. serving imports networking, so just use string.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"numActivators": {
						SchemaProps: spec.SchemaProps{
							Description: "NumActivators contains number of Activators that this revision should be assigned. O means  assign all.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"objectRef", "ProtocolType"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ObjectReference"},
	}
}

func schema_pkg_apis_networking_v1alpha1_ServerlessServiceStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServerlessServiceStatus describes the current state of the ServerlessService.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"serviceName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceName holds the name of a core K8s Service resource that load balances over the pods backing this Revision (activator or revision).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"privateServiceName": {
						SchemaProps: spec.SchemaProps{
							Description: "PrivateServiceName holds the name of a core K8s Service resource that load balances over the user service pods backing this Revision.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition"},
	}
}

func schema_pkg_apis_serving_v1_AnnotationParseError(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"Type": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"Value": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"Err": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("error"),
						},
					},
				},
				Required: []string{"Type", "Value", "Err"},
			},
		},
		Dependencies: []string{
			"error"},
	}
}

func schema_pkg_apis_serving_v1_Configuration(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Configuration represents the \"floating HEAD\" of a linear history of Revisions. Users create new Revisions by updating the Configuration's spec. The \"latest created\" revision's name is available under status, as is the \"latest ready\" revision's name. See also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#configuration",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.ConfigurationSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.ConfigurationStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1.ConfigurationSpec", "knative.dev/serving/pkg/apis/serving/v1.ConfigurationStatus"},
	}
}

func schema_pkg_apis_serving_v1_ConfigurationList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigurationList is a list of Configuration resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1.Configuration"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/serving/v1.Configuration"},
	}
}

func schema_pkg_apis_serving_v1_ConfigurationSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigurationSpec holds the desired state of the Configuration (from the client).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "Template holds the latest specification for the Revision to be stamped out.",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1.RevisionTemplateSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/serving/pkg/apis/serving/v1.RevisionTemplateSpec"},
	}
}

func schema_pkg_apis_serving_v1_ConfigurationStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigurationStatus communicates the observed state of the Configuration (from the controller).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"latestReadyRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestReadyRevisionName holds the name of the latest Revision stamped out from this Configuration that has had its \"Ready\" condition become \"True\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"latestCreatedRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestCreatedRevisionName is the last revision that was created from this Configuration. It might not be ready yet, for that use LatestReadyRevisionName.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition"},
	}
}

func schema_pkg_apis_serving_v1_ConfigurationStatusFields(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigurationStatusFields holds the fields of Configuration's status that are not generally shared.  This is defined separately and inlined so that other types can readily consume these fields via duck typing.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"latestReadyRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestReadyRevisionName holds the name of the latest Revision stamped out from this Configuration that has had its \"Ready\" condition become \"True\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"latestCreatedRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestCreatedRevisionName is the last revision that was created from this Configuration. It might not be ready yet, for that use LatestReadyRevisionName.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_serving_v1_ContainerStatuses(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ContainerStatuses holds the information of container name and image digest value",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"imageDigest": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_serving_v1_LastPinnedParseError(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"Type": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"Value": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"Err": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("error"),
						},
					},
				},
				Required: []string{"Type", "Value", "Err"},
			},
		},
		Dependencies: []string{
			"error"},
	}
}

func schema_pkg_apis_serving_v1_Revision(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Revision is an immutable snapshot of code and configuration.  A revision references a container image. Revisions are created by updates to a Configuration.\n\nSee also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#revision",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.RevisionSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.RevisionStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1.RevisionSpec", "knative.dev/serving/pkg/apis/serving/v1.RevisionStatus"},
	}
}

func schema_pkg_apis_serving_v1_RevisionList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RevisionList is a list of Revision resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1.Revision"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/serving/v1.Revision"},
	}
}

func schema_pkg_apis_serving_v1_RevisionSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RevisionSpec holds the desired state of the Revision (from the client).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"ephemeralContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource. This field is alpha-level and is only honored by servers that enable the EphemeralContainers feature.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.EphemeralContainer"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"dnsPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceAccount": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"automountServiceAccountToken": {
						SchemaProps: spec.SchemaProps{
							Description: "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"nodeName": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostNetwork": {
						SchemaProps: spec.SchemaProps{
							Description: "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostPID": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's pid namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostIPC": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's ipc namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"shareProcessNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false. This field is beta-level and may be disabled with the PodShareProcessNamespace feature.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"hostname": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subdomain": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the pod will not have a domainname at all.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tolerations": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"hostAliases": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "ip",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.HostAlias"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"dnsConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
							Ref:         ref("k8s.io/api/core/v1.PodDNSConfig"),
						},
					},
					"readinessGates": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.PodReadinessGate"),
									},
								},
							},
						},
					},
					"runtimeClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md This is a beta feature as of Kubernetes v1.14.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"enableServiceLinks": {
						SchemaProps: spec.SchemaProps{
							Description: "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"preemptionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is alpha-level and is only honored by servers that enable the NonPreemptingPriority feature.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"overhead": {
						SchemaProps: spec.SchemaProps{
							Description: "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable the PodOverhead feature.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
									},
								},
							},
						},
					},
					"topologySpreadConstraints": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"topologyKey",
									"whenUnsatisfiable",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "topologyKey",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. This field is alpha-level and is only honored by clusters that enables the EvenPodsSpread feature. All topologySpreadConstraints are ANDed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.TopologySpreadConstraint"),
									},
								},
							},
						},
					},
					"containerConcurrency": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerConcurrency specifies the maximum allowed in-flight (concurrent) requests per container of the Revision.  Defaults to `0` which means concurrency to the application is not limited, and the system decides the target concurrency for the autoscaler.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "TimeoutSeconds holds the max duration the instance is allowed for responding to a request.  If unspecified, a system default will be provided.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
				Required: []string{"containers"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.EphemeralContainer", "k8s.io/api/core/v1.HostAlias", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodDNSConfig", "k8s.io/api/core/v1.PodReadinessGate", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.TopologySpreadConstraint", "k8s.io/api/core/v1.Volume", "k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_serving_v1_RevisionStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RevisionStatus communicates the observed state of the Revision (from the controller).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"serviceName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceName holds the name of a core Kubernetes Service resource that load balances over the pods backing this Revision.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"logUrl": {
						SchemaProps: spec.SchemaProps{
							Description: "LogURL specifies the generated logging url for this particular revision based on the revision url template specified in the controller's config.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imageDigest": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedImageDigest holds the resolved digest for the image specified within .Spec.Container.Image. The digest is resolved during the creation of Revision. This field holds the digest value regardless of whether a tag or digest was originally specified in the Container object. It may be empty if the image comes from a registry listed to skip resolution. If multiple containers specified then DeprecatedImageDigest holds the digest for serving container. DEPRECATED Use ContainerStatuses instead. ref https://kubernetes.io/docs/reference/using-api/deprecation-policy for deprecation.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containerStatuses": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerStatuses is a slice of images present in .Spec.Container[*].Image to their respective digests and their container name. The digests are resolved during the creation of Revision. ContainerStatuses holds the container name and image digests for both serving and non serving containers. ref: http://bit.ly/image-digests",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1.ContainerStatuses"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition", "knative.dev/serving/pkg/apis/serving/v1.ContainerStatuses"},
	}
}

func schema_pkg_apis_serving_v1_RevisionTemplateSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RevisionTemplateSpec describes the data a revision should have when created from a template. Based on: https://github.com/kubernetes/api/blob/e771f807/core/v1/types.go#L3179-L3190",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.RevisionSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1.RevisionSpec"},
	}
}

func schema_pkg_apis_serving_v1_Route(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Route is responsible for configuring ingress over a collection of Revisions. Some of the Revisions a Route distributes traffic over may be specified by referencing the Configuration responsible for creating them; in these cases the Route is additionally responsible for monitoring the Configuration for \"latest ready revision\" changes, and smoothly rolling out latest revisions. See also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#route",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Spec holds the desired state of the Route (from the client).",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1.RouteSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status communicates the observed state of the Route (from the controller).",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1.RouteStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1.RouteSpec", "knative.dev/serving/pkg/apis/serving/v1.RouteStatus"},
	}
}

func schema_pkg_apis_serving_v1_RouteList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RouteList is a list of Route resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1.Route"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/serving/v1.Route"},
	}
}

func schema_pkg_apis_serving_v1_RouteSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RouteSpec holds the desired state of the Route (from the client).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"traffic": {
						SchemaProps: spec.SchemaProps{
							Description: "Traffic specifies how to distribute traffic over a collection of revisions and configurations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1.TrafficTarget"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/serving/pkg/apis/serving/v1.TrafficTarget"},
	}
}

func schema_pkg_apis_serving_v1_RouteStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RouteStatus communicates the observed state of the Route (from the controller).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
					"address": {
						SchemaProps: spec.SchemaProps{
							Description: "Address holds the information needed for a Route to be the target of an event.",
							Ref:         ref("knative.dev/pkg/apis/duck/v1.Addressable"),
						},
					},
					"traffic": {
						SchemaProps: spec.SchemaProps{
							Description: "Traffic holds the configured traffic distribution. These entries will always contain RevisionName references. When ConfigurationName appears in the spec, this will hold the LatestReadyRevisionName that we last observed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1.TrafficTarget"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition", "knative.dev/pkg/apis.URL", "knative.dev/pkg/apis/duck/v1.Addressable", "knative.dev/serving/pkg/apis/serving/v1.TrafficTarget"},
	}
}

func schema_pkg_apis_serving_v1_RouteStatusFields(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RouteStatusFields holds the fields of Route's status that are not generally shared.  This is defined separately and inlined so that other types can readily consume these fields via duck typing.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
					"address": {
						SchemaProps: spec.SchemaProps{
							Description: "Address holds the information needed for a Route to be the target of an event.",
							Ref:         ref("knative.dev/pkg/apis/duck/v1.Addressable"),
						},
					},
					"traffic": {
						SchemaProps: spec.SchemaProps{
							Description: "Traffic holds the configured traffic distribution. These entries will always contain RevisionName references. When ConfigurationName appears in the spec, this will hold the LatestReadyRevisionName that we last observed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1.TrafficTarget"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.URL", "knative.dev/pkg/apis/duck/v1.Addressable", "knative.dev/serving/pkg/apis/serving/v1.TrafficTarget"},
	}
}

func schema_pkg_apis_serving_v1_Service(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Service acts as a top-level container that manages a Route and Configuration which implement a network service. Service exists to provide a singular abstraction which can be access controlled, reasoned about, and which encapsulates software lifecycle decisions such as rollout policy and team resource ownership. Service acts only as an orchestrator of the underlying Routes and Configurations (much as a kubernetes Deployment orchestrates ReplicaSets), and its usage is optional but recommended.\n\nThe Service's controller will track the statuses of its owned Configuration and Route, reflecting their statuses and conditions as its own.\n\nSee also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#service",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.ServiceSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.ServiceStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1.ServiceSpec", "knative.dev/serving/pkg/apis/serving/v1.ServiceStatus"},
	}
}

func schema_pkg_apis_serving_v1_ServiceList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServiceList is a list of Service resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1.Service"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/serving/v1.Service"},
	}
}

func schema_pkg_apis_serving_v1_ServiceSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServiceSpec represents the configuration for the Service object. A Service's specification is the union of the specifications for a Route and Configuration.  The Service restricts what can be expressed in these fields, e.g. the Route must reference the provided Configuration; however, these limitations also enable friendlier defaulting, e.g. Route never needs a Configuration name, and may be defaulted to the appropriate \"run latest\" spec.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "Template holds the latest specification for the Revision to be stamped out.",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1.RevisionTemplateSpec"),
						},
					},
					"traffic": {
						SchemaProps: spec.SchemaProps{
							Description: "Traffic specifies how to distribute traffic over a collection of revisions and configurations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1.TrafficTarget"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/serving/pkg/apis/serving/v1.RevisionTemplateSpec", "knative.dev/serving/pkg/apis/serving/v1.TrafficTarget"},
	}
}

func schema_pkg_apis_serving_v1_ServiceStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServiceStatus represents the Status stanza of the Service resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"latestReadyRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestReadyRevisionName holds the name of the latest Revision stamped out from this Configuration that has had its \"Ready\" condition become \"True\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"latestCreatedRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestCreatedRevisionName is the last revision that was created from this Configuration. It might not be ready yet, for that use LatestReadyRevisionName.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
					"address": {
						SchemaProps: spec.SchemaProps{
							Description: "Address holds the information needed for a Route to be the target of an event.",
							Ref:         ref("knative.dev/pkg/apis/duck/v1.Addressable"),
						},
					},
					"traffic": {
						SchemaProps: spec.SchemaProps{
							Description: "Traffic holds the configured traffic distribution. These entries will always contain RevisionName references. When ConfigurationName appears in the spec, this will hold the LatestReadyRevisionName that we last observed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1.TrafficTarget"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition", "knative.dev/pkg/apis.URL", "knative.dev/pkg/apis/duck/v1.Addressable", "knative.dev/serving/pkg/apis/serving/v1.TrafficTarget"},
	}
}

func schema_pkg_apis_serving_v1_TrafficTarget(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TrafficTarget holds a single entry of the routing table for a Route.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"tag": {
						SchemaProps: spec.SchemaProps{
							Description: "Tag is optionally used to expose a dedicated url for referencing this target exclusively.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"revisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "RevisionName of a specific revision to which to send this portion of traffic.  This is mutually exclusive with ConfigurationName.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"configurationName": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigurationName of a configuration to whose latest revision we will send this portion of traffic. When the \"status.latestReadyRevisionName\" of the referenced configuration changes, we will automatically migrate traffic from the prior \"latest ready\" revision to the new one.  This field is never set in Route's status, only its spec.  This is mutually exclusive with RevisionName.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"latestRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestRevision may be optionally provided to indicate that the latest ready Revision of the Configuration should be used for this traffic target.  When provided LatestRevision must be true if RevisionName is empty; it must be false when RevisionName is non-empty.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"percent": {
						SchemaProps: spec.SchemaProps{
							Description: "Percent indicates that percentage based routing should be used and the value indicates the percent of traffic that is be routed to this Revision or Configuration. `0` (zero) mean no traffic, `100` means all traffic. When percentage based routing is being used the follow rules apply: - the sum of all percent values must equal 100 - when not specified, the implied value for `percent` is zero for\n  that particular Revision or Configuration",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL displays the URL for accessing named traffic targets. URL is displayed in status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.URL"},
	}
}

func schema_pkg_apis_serving_v1_hdcnKey(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "hdcnKey is used as the key for associating information with a context.Context.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_pkg_apis_serving_v1_lemonadeKey(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "lemonadeKey is used as the key for associating information with a context.Context.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_pkg_apis_serving_v1alpha1_AnnotationParseError(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"Type": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"Value": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"Err": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("error"),
						},
					},
				},
				Required: []string{"Type", "Value", "Err"},
			},
		},
		Dependencies: []string{
			"error"},
	}
}

func schema_pkg_apis_serving_v1alpha1_CannotConvertError(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CannotConvertError is returned when a field cannot be converted.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"Message": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"Field": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
				Required: []string{"Message", "Field"},
			},
		},
	}
}

func schema_pkg_apis_serving_v1alpha1_Configuration(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Configuration represents the \"floating HEAD\" of a linear history of Revisions, and optionally how the containers those revisions reference are built. Users create new Revisions by updating the Configuration's spec. The \"latest created\" revision's name is available under status, as is the \"latest ready\" revision's name. See also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#configuration",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Spec holds the desired state of the Configuration (from the client).",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status communicates the observed state of the Configuration (from the controller).",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationSpec", "knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationStatus"},
	}
}

func schema_pkg_apis_serving_v1alpha1_ConfigurationList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigurationList is a list of Configuration resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.Configuration"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/serving/v1alpha1.Configuration"},
	}
}

func schema_pkg_apis_serving_v1alpha1_ConfigurationSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigurationSpec holds the desired state of the Configuration (from the client).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"generation": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedGeneration was used prior in Kubernetes versions <1.11 when metadata.generation was not being incremented by the api server\n\nThis property will be dropped in future Knative releases and should not be used - use metadata.generation\n\nTracking issue: https://github.com/knative/serving/issues/643",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"build": {
						SchemaProps: spec.SchemaProps{
							Description: "Build optionally holds the specification for the build to perform to produce the Revision's container image.",
							Ref:         ref("k8s.io/apimachinery/pkg/runtime.RawExtension"),
						},
					},
					"revisionTemplate": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedRevisionTemplate holds the latest specification for the Revision to be stamped out. If a Build specification is provided, then the DeprecatedRevisionTemplate's BuildName field will be populated with the name of the Build object created to produce the container for the Revision. DEPRECATED Use Template instead.",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionTemplateSpec"),
						},
					},
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "Template holds the latest specification for the Revision to be stamped out.",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionTemplateSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/runtime.RawExtension", "knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionTemplateSpec"},
	}
}

func schema_pkg_apis_serving_v1alpha1_ConfigurationStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigurationStatus communicates the observed state of the Configuration (from the controller).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"latestReadyRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestReadyRevisionName holds the name of the latest Revision stamped out from this Configuration that has had its \"Ready\" condition become \"True\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"latestCreatedRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestCreatedRevisionName is the last revision that was created from this Configuration. It might not be ready yet, for that use LatestReadyRevisionName.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition"},
	}
}

func schema_pkg_apis_serving_v1alpha1_ConfigurationStatusFields(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigurationStatusFields holds all of the non-duckv1.Status status fields of a Route. These are defined outline so that we can also inline them into Service, and more easily copy them.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"latestReadyRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestReadyRevisionName holds the name of the latest Revision stamped out from this Configuration that has had its \"Ready\" condition become \"True\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"latestCreatedRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestCreatedRevisionName is the last revision that was created from this Configuration. It might not be ready yet, for that use LatestReadyRevisionName.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_serving_v1alpha1_ContainerStatuses(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ContainerStatuses holds the information of container name and image digest value",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"imageDigest": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_serving_v1alpha1_LastPinnedParseError(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"Type": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"Value": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"Err": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("error"),
						},
					},
				},
				Required: []string{"Type", "Value", "Err"},
			},
		},
		Dependencies: []string{
			"error"},
	}
}

func schema_pkg_apis_serving_v1alpha1_ManualType(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ManualType contains the options for configuring a manual service. See ServiceSpec for more details.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_pkg_apis_serving_v1alpha1_PinnedType(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PinnedType is DEPRECATED. ReleaseType should be used instead. To get the behavior of PinnedType set ReleaseType.Revisions to []string{PinnedType.RevisionName} and ReleaseType.RolloutPercent to 0.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"revisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "The revision name to pin this service to until changed to a different service type.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"configuration": {
						SchemaProps: spec.SchemaProps{
							Description: "The configuration for this service.",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationSpec"},
	}
}

func schema_pkg_apis_serving_v1alpha1_ReleaseType(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ReleaseType contains the options for slowly releasing revisions. See ServiceSpec for more details.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"revisions": {
						SchemaProps: spec.SchemaProps{
							Description: "Revisions is an ordered list of 1 or 2 revisions. The first will have a TrafficTarget with a name of \"current\" and the second will have a name of \"candidate\".",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"rolloutPercent": {
						SchemaProps: spec.SchemaProps{
							Description: "RolloutPercent is the percent of traffic that should be sent to the \"candidate\" revision. Valid values are between 0 and 99 inclusive.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"configuration": {
						SchemaProps: spec.SchemaProps{
							Description: "The configuration for this service. All revisions from this service must come from a single configuration.",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationSpec"},
	}
}

func schema_pkg_apis_serving_v1alpha1_Revision(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Revision is an immutable snapshot of code and configuration.  A revision references a container image, and optionally a build that is responsible for materializing that container image from source. Revisions are created by updates to a Configuration.\n\nSee also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#revision",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Spec holds the desired state of the Revision (from the client).",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status communicates the observed state of the Revision (from the controller).",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionSpec", "knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionStatus"},
	}
}

func schema_pkg_apis_serving_v1alpha1_RevisionList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RevisionList is a list of Revision resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.Revision"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/serving/v1alpha1.Revision"},
	}
}

func schema_pkg_apis_serving_v1alpha1_RevisionSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RevisionSpec holds the desired state of the Revision (from the client).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"ephemeralContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource. This field is alpha-level and is only honored by servers that enable the EphemeralContainers feature.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.EphemeralContainer"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"dnsPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "",
									},
								},
							},
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceAccount": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"automountServiceAccountToken": {
						SchemaProps: spec.SchemaProps{
							Description: "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"nodeName": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostNetwork": {
						SchemaProps: spec.SchemaProps{
							Description: "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostPID": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's pid namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostIPC": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's ipc namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"shareProcessNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false. This field is beta-level and may be disabled with the PodShareProcessNamespace feature.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"hostname": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subdomain": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the pod will not have a domainname at all.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tolerations": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"hostAliases": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "ip",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.HostAlias"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"dnsConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
							Ref:         ref("k8s.io/api/core/v1.PodDNSConfig"),
						},
					},
					"readinessGates": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.PodReadinessGate"),
									},
								},
							},
						},
					},
					"runtimeClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md This is a beta feature as of Kubernetes v1.14.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"enableServiceLinks": {
						SchemaProps: spec.SchemaProps{
							Description: "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"preemptionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is alpha-level and is only honored by servers that enable the NonPreemptingPriority feature.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"overhead": {
						SchemaProps: spec.SchemaProps{
							Description: "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable the PodOverhead feature.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
									},
								},
							},
						},
					},
					"topologySpreadConstraints": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"topologyKey",
									"whenUnsatisfiable",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "topologyKey",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. This field is alpha-level and is only honored by clusters that enables the EvenPodsSpread feature. All topologySpreadConstraints are ANDed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/api/core/v1.TopologySpreadConstraint"),
									},
								},
							},
						},
					},
					"containerConcurrency": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerConcurrency specifies the maximum allowed in-flight (concurrent) requests per container of the Revision.  Defaults to `0` which means concurrency to the application is not limited, and the system decides the target concurrency for the autoscaler.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "TimeoutSeconds holds the max duration the instance is allowed for responding to a request.  If unspecified, a system default will be provided.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"generation": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedGeneration was used prior in Kubernetes versions <1.11 when metadata.generation was not being incremented by the api server\n\nThis property will be dropped in future Knative releases and should not be used - use metadata.generation\n\nTracking issue: https://github.com/knative/serving/issues/643",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"servingState": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedServingState holds a value describing the desired state the Kubernetes resources should be in for this Revision. Users must not specify this when creating a revision. These values are no longer updated by the system.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"container": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedContainer defines the unit of execution for this Revision. In the context of a Revision, we disallow a number of the fields of this Container, including: name and lifecycle. See also the runtime contract for more information about the execution environment: https://github.com/knative/serving/blob/master/docs/runtime-contract.md",
							Ref:         ref("k8s.io/api/core/v1.Container"),
						},
					},
				},
				Required: []string{"containers"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.EphemeralContainer", "k8s.io/api/core/v1.HostAlias", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodDNSConfig", "k8s.io/api/core/v1.PodReadinessGate", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.TopologySpreadConstraint", "k8s.io/api/core/v1.Volume", "k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_serving_v1alpha1_RevisionStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RevisionStatus communicates the observed state of the Revision (from the controller).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"serviceName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceName holds the name of a core Kubernetes Service resource that load balances over the pods backing this Revision.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"logUrl": {
						SchemaProps: spec.SchemaProps{
							Description: "LogURL specifies the generated logging url for this particular revision based on the revision url template specified in the controller's config.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imageDigest": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedImageDigest holds the resolved digest for the image specified within .Spec.Container.Image. The digest is resolved during the creation of Revision. This field holds the digest value regardless of whether a tag or digest was originally specified in the Container object. It may be empty if the image comes from a registry listed to skip resolution. If multiple containers specified then DeprecatedImageDigest holds the digest for serving container. DEPRECATED Use ImageDigests instead. ref https://kubernetes.io/docs/reference/using-api/deprecation-policy for deprecation.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containerStatuses": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerStatuses is a slice of images present in .Spec.Container[*].Image to their respective digests and their container name. The digests are resolved during the creation of Revision. ContainerStatuses holds the container name and image digests for both serving and non serving containers. ref: http://bit.ly/image-digests",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.ContainerStatuses"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition", "knative.dev/serving/pkg/apis/serving/v1alpha1.ContainerStatuses"},
	}
}

func schema_pkg_apis_serving_v1alpha1_RevisionTemplateSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RevisionTemplateSpec describes the data a revision should have when created from a template. Based on: https://github.com/kubernetes/api/blob/e771f807/core/v1/types.go#L3179-L3190",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionSpec"},
	}
}

func schema_pkg_apis_serving_v1alpha1_Route(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Route is responsible for configuring ingress over a collection of Revisions. Some of the Revisions a Route distributes traffic over may be specified by referencing the Configuration responsible for creating them; in these cases the Route is additionally responsible for monitoring the Configuration for \"latest ready\" revision changes, and smoothly rolling out latest revisions. See also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#route",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Spec holds the desired state of the Route (from the client).",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.RouteSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status communicates the observed state of the Route (from the controller).",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.RouteStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1alpha1.RouteSpec", "knative.dev/serving/pkg/apis/serving/v1alpha1.RouteStatus"},
	}
}

func schema_pkg_apis_serving_v1alpha1_RouteList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RouteList is a list of Route resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.Route"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/serving/v1alpha1.Route"},
	}
}

func schema_pkg_apis_serving_v1alpha1_RouteSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RouteSpec holds the desired state of the Route (from the client).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"generation": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedGeneration was used prior in Kubernetes versions <1.11 when metadata.generation was not being incremented by the api server\n\nThis property will be dropped in future Knative releases and should not be used - use metadata.generation\n\nTracking issue: https://github.com/knative/serving/issues/643",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"traffic": {
						SchemaProps: spec.SchemaProps{
							Description: "Traffic specifies how to distribute traffic over a collection of Knative Serving Revisions and Configurations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.TrafficTarget"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/serving/pkg/apis/serving/v1alpha1.TrafficTarget"},
	}
}

func schema_pkg_apis_serving_v1alpha1_RouteStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RouteStatus communicates the observed state of the Route (from the controller).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
					"domain": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedDomain holds the top-level domain that will distribute traffic over the provided targets. It generally has the form {route-name}.{route-namespace}.{cluster-level-suffix}",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"domainInternal": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedDomainInternal holds the top-level domain that will distribute traffic over the provided targets from inside the cluster. It generally has the form {route-name}.{route-namespace}.svc.{cluster-domain-name} DEPRECATED: Use Address instead.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"address": {
						SchemaProps: spec.SchemaProps{
							Description: "Address holds the information needed for a Route to be the target of an event.",
							Ref:         ref("knative.dev/pkg/apis/duck/v1alpha1.Addressable"),
						},
					},
					"traffic": {
						SchemaProps: spec.SchemaProps{
							Description: "Traffic holds the configured traffic distribution. These entries will always contain RevisionName references. When ConfigurationName appears in the spec, this will hold the LatestReadyRevisionName that we last observed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.TrafficTarget"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition", "knative.dev/pkg/apis.URL", "knative.dev/pkg/apis/duck/v1alpha1.Addressable", "knative.dev/serving/pkg/apis/serving/v1alpha1.TrafficTarget"},
	}
}

func schema_pkg_apis_serving_v1alpha1_RouteStatusFields(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RouteStatusFields holds all of the non-duckv1.Status status fields of a Route. These are defined outline so that we can also inline them into Service, and more easily copy them.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
					"domain": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedDomain holds the top-level domain that will distribute traffic over the provided targets. It generally has the form {route-name}.{route-namespace}.{cluster-level-suffix}",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"domainInternal": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedDomainInternal holds the top-level domain that will distribute traffic over the provided targets from inside the cluster. It generally has the form {route-name}.{route-namespace}.svc.{cluster-domain-name} DEPRECATED: Use Address instead.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"address": {
						SchemaProps: spec.SchemaProps{
							Description: "Address holds the information needed for a Route to be the target of an event.",
							Ref:         ref("knative.dev/pkg/apis/duck/v1alpha1.Addressable"),
						},
					},
					"traffic": {
						SchemaProps: spec.SchemaProps{
							Description: "Traffic holds the configured traffic distribution. These entries will always contain RevisionName references. When ConfigurationName appears in the spec, this will hold the LatestReadyRevisionName that we last observed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.TrafficTarget"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.URL", "knative.dev/pkg/apis/duck/v1alpha1.Addressable", "knative.dev/serving/pkg/apis/serving/v1alpha1.TrafficTarget"},
	}
}

func schema_pkg_apis_serving_v1alpha1_RunLatestType(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RunLatestType contains the options for always having a route to the latest configuration. See ServiceSpec for more details.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"configuration": {
						SchemaProps: spec.SchemaProps{
							Description: "The configuration for this service.",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/serving/pkg/apis/serving/v1alpha1.ConfigurationSpec"},
	}
}

func schema_pkg_apis_serving_v1alpha1_Service(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Service acts as a top-level container that manages a set of Routes and Configurations which implement a network service. Service exists to provide a singular abstraction which can be access controlled, reasoned about, and which encapsulates software lifecycle decisions such as rollout policy and team resource ownership. Service acts only as an orchestrator of the underlying Routes and Configurations (much as a kubernetes Deployment orchestrates ReplicaSets), and its usage is optional but recommended.\n\nThe Service's controller will track the statuses of its owned Configuration and Route, reflecting their statuses and conditions as its own.\n\nSee also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#service",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.ServiceSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.ServiceStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1alpha1.ServiceSpec", "knative.dev/serving/pkg/apis/serving/v1alpha1.ServiceStatus"},
	}
}

func schema_pkg_apis_serving_v1alpha1_ServiceList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServiceList is a list of Service resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.Service"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/serving/v1alpha1.Service"},
	}
}

func schema_pkg_apis_serving_v1alpha1_ServiceSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServiceSpec represents the configuration for the Service object. Exactly one of its members (other than Generation) must be specified. Services can either track the latest ready revision of a configuration or be pinned to a specific revision.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"generation": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedGeneration was used prior in Kubernetes versions <1.11 when metadata.generation was not being incremented by the api server\n\nThis property will be dropped in future Knative releases and should not be used - use metadata.generation\n\nTracking issue: https://github.com/knative/serving/issues/643",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"runLatest": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedRunLatest defines a simple Service. It will automatically configure a route that keeps the latest ready revision from the supplied configuration running.",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.RunLatestType"),
						},
					},
					"pinned": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedPinned is DEPRECATED in favor of ReleaseType",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.PinnedType"),
						},
					},
					"manual": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedManual mode enables users to start managing the underlying Route and Configuration resources directly.  This advanced usage is intended as a path for users to graduate from the limited capabilities of Service to the full power of Route.",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.ManualType"),
						},
					},
					"release": {
						SchemaProps: spec.SchemaProps{
							Description: "Release enables gradual promotion of new revisions by allowing traffic to be split between two revisions. This type replaces the deprecated Pinned type.",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.ReleaseType"),
						},
					},
					"generation": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedGeneration was used prior in Kubernetes versions <1.11 when metadata.generation was not being incremented by the api server\n\nThis property will be dropped in future Knative releases and should not be used - use metadata.generation\n\nTracking issue: https://github.com/knative/serving/issues/643",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"build": {
						SchemaProps: spec.SchemaProps{
							Description: "Build optionally holds the specification for the build to perform to produce the Revision's container image.",
							Ref:         ref("k8s.io/apimachinery/pkg/runtime.RawExtension"),
						},
					},
					"revisionTemplate": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedRevisionTemplate holds the latest specification for the Revision to be stamped out. If a Build specification is provided, then the DeprecatedRevisionTemplate's BuildName field will be populated with the name of the Build object created to produce the container for the Revision. DEPRECATED Use Template instead.",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionTemplateSpec"),
						},
					},
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "Template holds the latest specification for the Revision to be stamped out.",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionTemplateSpec"),
						},
					},
					"generation": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedGeneration was used prior in Kubernetes versions <1.11 when metadata.generation was not being incremented by the api server\n\nThis property will be dropped in future Knative releases and should not be used - use metadata.generation\n\nTracking issue: https://github.com/knative/serving/issues/643",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"traffic": {
						SchemaProps: spec.SchemaProps{
							Description: "Traffic specifies how to distribute traffic over a collection of Knative Serving Revisions and Configurations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.TrafficTarget"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/runtime.RawExtension", "knative.dev/serving/pkg/apis/serving/v1alpha1.ManualType", "knative.dev/serving/pkg/apis/serving/v1alpha1.PinnedType", "knative.dev/serving/pkg/apis/serving/v1alpha1.ReleaseType", "knative.dev/serving/pkg/apis/serving/v1alpha1.RevisionTemplateSpec", "knative.dev/serving/pkg/apis/serving/v1alpha1.RunLatestType", "knative.dev/serving/pkg/apis/serving/v1alpha1.TrafficTarget"},
	}
}

func schema_pkg_apis_serving_v1alpha1_ServiceStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServiceStatus represents the Status stanza of the Service resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
					"domain": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedDomain holds the top-level domain that will distribute traffic over the provided targets. It generally has the form {route-name}.{route-namespace}.{cluster-level-suffix}",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"domainInternal": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedDomainInternal holds the top-level domain that will distribute traffic over the provided targets from inside the cluster. It generally has the form {route-name}.{route-namespace}.svc.{cluster-domain-name} DEPRECATED: Use Address instead.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"address": {
						SchemaProps: spec.SchemaProps{
							Description: "Address holds the information needed for a Route to be the target of an event.",
							Ref:         ref("knative.dev/pkg/apis/duck/v1alpha1.Addressable"),
						},
					},
					"traffic": {
						SchemaProps: spec.SchemaProps{
							Description: "Traffic holds the configured traffic distribution. These entries will always contain RevisionName references. When ConfigurationName appears in the spec, this will hold the LatestReadyRevisionName that we last observed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1alpha1.TrafficTarget"),
									},
								},
							},
						},
					},
					"latestReadyRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestReadyRevisionName holds the name of the latest Revision stamped out from this Configuration that has had its \"Ready\" condition become \"True\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"latestCreatedRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestCreatedRevisionName is the last revision that was created from this Configuration. It might not be ready yet, for that use LatestReadyRevisionName.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.Condition", "knative.dev/pkg/apis.URL", "knative.dev/pkg/apis/duck/v1alpha1.Addressable", "knative.dev/serving/pkg/apis/serving/v1alpha1.TrafficTarget"},
	}
}

func schema_pkg_apis_serving_v1alpha1_TrafficTarget(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TrafficTarget holds a single entry of the routing table for a Route.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name is optionally used to expose a dedicated hostname for referencing this target exclusively. It has the form: {name}.${route.status.domain}",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tag": {
						SchemaProps: spec.SchemaProps{
							Description: "Tag is optionally used to expose a dedicated url for referencing this target exclusively.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"revisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "RevisionName of a specific revision to which to send this portion of traffic.  This is mutually exclusive with ConfigurationName.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"configurationName": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigurationName of a configuration to whose latest revision we will send this portion of traffic. When the \"status.latestReadyRevisionName\" of the referenced configuration changes, we will automatically migrate traffic from the prior \"latest ready\" revision to the new one.  This field is never set in Route's status, only its spec.  This is mutually exclusive with RevisionName.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"latestRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestRevision may be optionally provided to indicate that the latest ready Revision of the Configuration should be used for this traffic target.  When provided LatestRevision must be true if RevisionName is empty; it must be false when RevisionName is non-empty.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"percent": {
						SchemaProps: spec.SchemaProps{
							Description: "Percent indicates that percentage based routing should be used and the value indicates the percent of traffic that is be routed to this Revision or Configuration. `0` (zero) mean no traffic, `100` means all traffic. When percentage based routing is being used the follow rules apply: - the sum of all percent values must equal 100 - when not specified, the implied value for `percent` is zero for\n  that particular Revision or Configuration",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL displays the URL for accessing named traffic targets. URL is displayed in status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"knative.dev/pkg/apis.URL"},
	}
}

func schema_pkg_apis_serving_v1beta1_Configuration(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Configuration represents the \"floating HEAD\" of a linear history of Revisions. Users create new Revisions by updating the Configuration's spec. The \"latest created\" revision's name is available under status, as is the \"latest ready\" revision's name. See also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#configuration",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.ConfigurationSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.ConfigurationStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1.ConfigurationSpec", "knative.dev/serving/pkg/apis/serving/v1.ConfigurationStatus"},
	}
}

func schema_pkg_apis_serving_v1beta1_ConfigurationList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigurationList is a list of Configuration resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1beta1.Configuration"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/serving/v1beta1.Configuration"},
	}
}

func schema_pkg_apis_serving_v1beta1_Revision(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Revision is an immutable snapshot of code and configuration.  A revision references a container image. Revisions are created by updates to a Configuration.\n\nSee also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#revision",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.RevisionSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.RevisionStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1.RevisionSpec", "knative.dev/serving/pkg/apis/serving/v1.RevisionStatus"},
	}
}

func schema_pkg_apis_serving_v1beta1_RevisionList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RevisionList is a list of Revision resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1beta1.Revision"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/serving/v1beta1.Revision"},
	}
}

func schema_pkg_apis_serving_v1beta1_Route(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Route is responsible for configuring ingress over a collection of Revisions. Some of the Revisions a Route distributes traffic over may be specified by referencing the Configuration responsible for creating them; in these cases the Route is additionally responsible for monitoring the Configuration for \"latest ready revision\" changes, and smoothly rolling out latest revisions. See also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#route",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Spec holds the desired state of the Route (from the client).",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1.RouteSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status communicates the observed state of the Route (from the controller).",
							Ref:         ref("knative.dev/serving/pkg/apis/serving/v1.RouteStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1.RouteSpec", "knative.dev/serving/pkg/apis/serving/v1.RouteStatus"},
	}
}

func schema_pkg_apis_serving_v1beta1_RouteList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RouteList is a list of Route resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1beta1.Route"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/serving/v1beta1.Route"},
	}
}

func schema_pkg_apis_serving_v1beta1_Service(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Service acts as a top-level container that manages a Route and Configuration which implement a network service. Service exists to provide a singular abstraction which can be access controlled, reasoned about, and which encapsulates software lifecycle decisions such as rollout policy and team resource ownership. Service acts only as an orchestrator of the underlying Routes and Configurations (much as a kubernetes Deployment orchestrates ReplicaSets), and its usage is optional but recommended.\n\nThe Service's controller will track the statuses of its owned Configuration and Route, reflecting their statuses and conditions as its own.\n\nSee also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#service",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.ServiceSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("knative.dev/serving/pkg/apis/serving/v1.ServiceStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "knative.dev/serving/pkg/apis/serving/v1.ServiceSpec", "knative.dev/serving/pkg/apis/serving/v1.ServiceStatus"},
	}
}

func schema_pkg_apis_serving_v1beta1_ServiceList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServiceList is a list of Service resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("knative.dev/serving/pkg/apis/serving/v1beta1.Service"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "knative.dev/serving/pkg/apis/serving/v1beta1.Service"},
	}
}
